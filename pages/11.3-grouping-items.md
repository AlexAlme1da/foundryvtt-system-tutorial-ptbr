# Agrupando itens por tipo

Na maioria das vezes, você provavelmente não quer exibir todos os itens possuídos de um ator diretamente na ficha de personagem do ator. Se você tiver múltiplos tipos de itens (como itens, recursos e magias), esses devem ser ordenados em grupos e exibidos sob seus próprios títulos ou abas. Para fazer isso, precisaremos fazer alguns ajustes na nossa classe ActorSheet para agrupar os itens.

## template.json

Antes de agrupar itens, vamos garantir que você tenha múltiplos tipos de itens. Aqui está um exemplo rápido da definição de Item para o Boilerplate System, e também o ajustamos para que magias agora tenham um atributo `spellLevel` também, que usaremos para agrupá-las por nível mais tarde.

```json
"Item": {
  "types": ["item", "feature", "spell"],
  "templates": {
    "base": {
      "description": ""
    },
    "class": {
      "classes": [],
      "level": 0
    }
  },
  "item": {
    "templates": ["base"],
    "quantity": 1,
    "weight": 0
  },
  "feature": {
    "templates": ["base", "class"],
    "usage": "",
    "roll": ""
  },
  "spell": {
    "templates": ["base", "class"],
    "spellLevel": 1,
	"school": "",
	"save_dc": "",
	"effect": ""
  }
}
```

## actor-sheet.js

Precisamos fazer algumas mudanças na nossa classe ActorSheet para suportar o agrupamento de itens. Primeiro, vamos modificar nosso método `getData()`.

```js
  // ... continued ...
  /** @override */
  getData() {
    const data = super.getData();
    data.dtypes = ["String", "Number", "Boolean"];
    for (let attr of Object.values(data.data.attributes)) {
      attr.isCheckbox = attr.dtype === "Boolean";
    }

    // Prepare items.
    if (this.actor.data.type == 'character') {
      this._prepareCharacterItems(data);
    }

    return data;
  }
  // ... continued ...
```

Modificamos isso de antes para adicionar uma nova chamada `this._prepareCharacterItems(data);` se esta for uma entidade de personagem. Este é um método customizado, então agora também precisamos criar um método para isso diretamente abaixo de getData().

```js
  // ... continued ...
  /**
   * Organize and classify Items for Character sheets.
   *
   * @param {Object} actorData The actor to prepare.
   *
   * @return {undefined}
   */
  _prepareCharacterItems(sheetData) {
    const actorData = sheetData.actor;

    // Initialize containers.
    const gear = [];
    const features = [];
    const spells = {
      0: [],
      1: [],
      2: [],
      3: [],
      4: [],
      5: [],
      6: [],
      7: [],
      8: [],
      9: []
    };

    // Iterate through items, allocating to containers
    // let totalWeight = 0;
    for (let i of sheetData.items) {
      let item = i.data;
      i.img = i.img || DEFAULT_TOKEN;
      // Append to gear.
      if (i.type === 'item') {
        gear.push(i);
      }
      // Append to features.
      else if (i.type === 'feature') {
        features.push(i);
      }
      // Append to spells.
      else if (i.type === 'spell') {
        if (i.data.spellLevel != undefined) {
          spells[i.data.spellLevel].push(i);
        }
      }
    }

    // Assign and return
    actorData.gear = gear;
    actorData.features = features;
    actorData.spells = spells;
  }

  /* -------------------------------------------- */
  // ... continued ...
```

Há muita coisa acontecendo aqui! Vamos dividir isso em mais detalhes:

### Configuração

Primeiro, estamos configurando nossas variáveis.

```js
const actorData = sheetData.actor;

// Initialize containers.
const gear = [];
const features = []
const spells = {
  0: [],
  1: [],
  2: [],
  3: [],
  4: [],
  5: [],
  6: [],
  7: [],
  8: [],
  9: []
};
```
Estamos colocando os dados do ator em uma variável mais conveniente, e então inicializando arrays vazios para nossos vários tipos de itens. Magias estão sendo inicializadas como um objeto com chaves numéricas para que tenhamos múltiplos sub-contêineres para cada nível de magias. Se seu sistema tivesse menos níveis de magias, como apenas magias de nível ímpar, as chaves de número par poderiam simplesmente ser deletadas.

Uma coisa a notar é que também definimos um array `gear`. Como já temos um array de todos os itens no ator na chave `item`, teríamos problemas se colocássemos nossos itens com o subtipo `item` em um array com o mesmo nome.

### O Loop

Após a configuração inicial de variáveis, agora precisamos percorrer nossos itens e ordená-los.

```js
// Iterate through items, allocating to containers
// let totalWeight = 0;
for (let i of sheetData.items) {
  let item = i.data;
  i.img = i.img || DEFAULT_TOKEN;
  // Append to gear.
  if (i.type === 'item') {
    gear.push(i);
  }
  // Append to features.
  else if (i.type === 'feature') {
    features.push(i);
  }
  // Append to spells.
  else if (i.type === 'spell') {
    if (i.data.spellLevel != undefined) {
      spells[i.data.spellLevel].push(i);
    }
  }
}
```

Primeiro, fazemos um loop `for (let i of sheetData.items)` para percorrer todos os itens possuídos neste ator. Fazemos alguma configuração inicial com o item e a imagem, e depois disso, temos uma série de declarações `if` para verificar o tipo de item e anexá-lo a um dos arrays de itens vazios que definimos anteriormente.

Para ambos os subtipos `item` e `feature`, só precisamos anexá-los aos seus respectivos arrays. Para magias, estamos fazendo um
pouco mais de lógica para verificar se a magia tem um spellLevel e então adicioná-la à chave spellLevel do array `spells`.

### Enviar os dados

Agora que todos os nossos arrays estão atualizados, só precisamos adicioná-los à nossa variável actorData como novas propriedades e eles se tornarão disponíveis nos nossos templates HTML.

```js
// Assign and return
actorData.gear = gear;
actorData.features = features;
actorData.spells = spells;
```

E isso é tudo para as mudanças no JS da nossa ficha de personagem! Agora vamos fazer algumas mudanças no nosso template `actor-sheet.html`.

- **Anterior:** [Criando botões roláveis com listeners de evento](https://github.com/AlexAlme1da/foundryvtt-system-tutorial-ptbr/blob/master/pages/11.1-rollable.md)
- **Próximo:** [Separando tipos de itens em abas](https://github.com/AlexAlme1da/foundryvtt-system-tutorial-ptbr/blob/master/pages/11.4-item-type-tabs.md)
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTQ1OTgwMzc3MCwyMDQzNTQxMzA2LDE3OD
I1Mzg4MzgsODg1NTk0NTE1LDE4NDg2MzgzMzIsMTkwMzU1MjIw
NCwxODQ4NjM4MzMyLC0xODA4MTk4MTkxLDExODE5OTI1NTMsLT
E4MjQyNTIzMzMsLTIwMzg2ODQxMzUsNTMzMzM4MDE2XX0=
-->
